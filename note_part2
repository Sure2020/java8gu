8 Gu Part2
51. 如何存ip地址，分为ipv4/6。   都有两种，用字符串或者整数。字符串比较占空间，而且比较大小也比整形慢。
字符串，没啥可说的。
整形，mysql中ipv4用binary(4)，也就是4字节，32 位存，先各段转为二进制，再去掉点号，最后二进制转为整型。
ipv6用binary(16)表示，也就是16*8=128字节。

52. rpc调用，客户端超时，服务端没超时，怎么回事。网络延迟或丢包；   客户端超时时间比服务端短

53. 为啥不建议用mq延迟队列实现订单到期关闭。
每个消息都要一个延迟消息，即使这个订单会立即关闭。仍然会创建延迟消息，消耗资源。   mq本身不支持延迟消息，即使支持，也有限制比如限制最长延迟时间。   消息有延迟。

54. 为什么不要在事务中做外部调用。因为外部调用不可控，如果外部调用性能差，回复延迟高，甚至报错等，会拖慢整个事务的性能，而且出错了不能回退。
建议是将事务和外部调用分离。   如果外部调用必须和数据库操作紧密集成，那可以使用补偿事务，用来处理外部调用失败的情况，用来撤销已经执行的外部调用。  

55. 如何做平滑的数据迁移。写旧读旧---双写读旧，可以借助flink\canal等数据同步工具实现，也可以自己写代码实现，先写旧库，成功后再写新库。---增量数据核对---存量数据迁移---存量数据核对---双写读新（灰度切流）---全量数据核对---写新读新（灰度切流）。

56. 使用分布式锁的时候，锁加在事物外面还是里面。这就是个加锁粒度的问题，建议锁加外面。防止即使加了锁仍然出现脏数据的问题。

57. 加了分布式锁，不就影响并发了吗，怎么回复这个问题。
加锁，是为了当时多个请求同时到达争抢资源然后发生意向不到的错误，出了错误还要处理，这反而影响了并发。加分布式锁，虽然拦住了这个用户的请求，但使得其他用户的请求得以正常执行，减少出错，这反而是提高了并发。

58. 数据库的乐观锁，悲观锁，和redis的分布式锁，区别和使用场景？悲观锁select for update实现，会锁表，适合并发高，更新和删除多的场景。是悲观地认为并发会发生，属于先加锁再干活。
乐观锁，往往通过版本号实现，其实在更新时也会加行级锁。认为并发不会发生，是先干活再加锁。
其实数据库的悲观锁和redos的分布式锁，作用差不多。其实redis分布式锁性能更好，支持锁重入和锁延期等。悲观锁有可能锁表。

59. 为什么很多公司禁止物理删除。
数据留痕，方便做数据分析，报表，定位问题等。
合规，很多业务比如金融，是要求要有历史数据方便回溯的。
性能，物理删除会影响数据库性能。
碎片，有时候物理删除了并不会立即删除，造成内存碎片。

60. 为什么不用分布式锁实现秒杀，(而是用lua脚本)。答案是，没必要！用lua脚本和使用redis分布式锁，性能差不多，而且可以利用lua脚本的原子性，避免超卖。reids锁的话还要查找redis缓存中的库存，判断是否超卖，更新缓存，判断数据库的库存，更新数据库等。需要和组件多次建立连接。业务变复杂。

lua脚本有原子性，是因为redis会封装成一个单独的事务，执行期间有其他事务，则等待。

61. 为什么不用BlockingQueue做消息队列。
不支持分布式，无法持久化，没有高级特性支持，比如消息确认，延迟消息等。没有管理和监控工具。
性能也差，kafka专门做过性能优化